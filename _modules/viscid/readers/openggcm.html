

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>viscid.readers.openggcm &mdash; Viscid 0.50.2 documentation</title>
  

  
  

  
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../../',
        VERSION:'0.50.2',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="Viscid 0.50.2 documentation" href="../../../index.html"/>
        <link rel="up" title="viscid.readers" href="../readers.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../index.html" class="icon icon-home"> Viscid</a>
        <form class="wy-form" action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#standard-setup">Standard Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#for-developers">For Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../philosophy.html">Philosophy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../philosophy.html#data-abstraction">Data Abstraction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../ex_reader.html">Reading/Plotting Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_reader.html#super-simple">Super Simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_reader.html#two-plots-one-figure">Two Plots, One Figure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_reader.html#playing-with-time">Playing with Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_reader.html#slicing-fields">Slicing Fields</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../ex_openggcm.html">OpenGGCM Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_openggcm.html#gse-coordinates">GSE coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_openggcm.html#ionosphere-files">Ionosphere Files</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../ex_calc.html">Calculator Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ex_calc.html#streamlines">Streamlines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../command_line.html">Command Line Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../command_line.html#p2d">p2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../command_line.html#viscid-diff">viscid_diff</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../command_line.html#bitmaskbits">bitmaskbits</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../viscid.html">viscid package</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">Viscid</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../../../index.html">Docs</a> &raquo;</li>
  <li><a href="">viscid.readers.openggcm</a></li>
  
</ul>
<hr/>

          
  <h1>Source code for viscid.readers.openggcm</h1><pre>
#!/usr/bin/env python
""" Wrapper grid for some OpenGGCM convenience """

from __future__ import print_function
import os
import re

import numpy as np
try:
    import numexpr
    _has_numexpr = True
except ImportError:
    _has_numexpr = False

from viscid.readers import xdmf
from viscid import grid
from viscid import field
from viscid.calculator import plasma

<div class="viewcode-block" id="GGCMGrid"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid">[docs]</a>class GGCMGrid(grid.Grid):
    r""" This defines some cool openggcm convinience stuff...
    The following attributes can be set by saying

        ``viscid.grid.readers.openggcm.GGCMGrid.flag = value``.

    This should be done before a call to readers.load_file so that all
    grids that are instantiated have the flags you want.

    Derived quantities accessable by dictionary lookup
        - T: Temperature, for now, just pressure / density
        - bx, by, bz: CC mag field components, if not already stored by
          component)
        - b: mag field as vector, layout affected by
          GGCMGrid.derived_vector_layout
        - v: velocity as vector, same idea as b
        - beta: plasma beta, just pp/b^2
        - psi: flux function (only works for 2d files/grids)

    Attributes:
        mhd_to_gse_on_read (bool): flips arrays on load to be in
            GSE crds (default is False)
        copy_on_transform (bool): True means array will be contiguous
            after transform (if one is done), but makes data load
            50\%-60\% slower (default is True)
        force_vector_layout (str): inherited from grid.Grid, enforces
            layout for vector fields on load (default is
            :py:const:`viscid.field.LAYOUT_DEFAULT`)
    """
    _flip_vect_comp_names = "bx, by, b1x, b1y, " \
                            "vx, vy, rv1x, rv1y, " \
                            "jx, jy, ex, ey, ex_cc, ey_cc".split(', ')
    _flip_vect_names = "v, b, j, xj".split(', ')
    # _flip_vect_comp_names = []
    # _flip_vect_names = []

    mhd_to_gse_on_read = False
    copy_on_transform = False

<div class="viewcode-block" id="GGCMGrid.mhd2gse_field_scalar"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid.mhd2gse_field_scalar">[docs]</a>    def mhd2gse_field_scalar(self, fld, arr):  # pylint: disable=W0613
        # Note: field._data will be set to whatever is returned (after
        # being reshaped to the crd shape), so if you return a view,
        # field._data will be a view
        return np.array(arr[:, ::-1, ::-1], copy=self.copy_on_transform)
</div>
<div class="viewcode-block" id="GGCMGrid.mhd2gse_field_scalar_m1"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid.mhd2gse_field_scalar_m1">[docs]</a>    def mhd2gse_field_scalar_m1(self, fld, arr):  # pylint: disable=W0613
        # This is always copied since the -1.0 * arr will need new
        # memory anyway
        a = np.array(arr[:, ::-1, ::-1], copy=False)

        if self.copy_on_transform:
            if _has_numexpr:
                m1 = np.array([-1.0], dtype=arr.dtype)  # pylint: disable=unused-variable
                a = numexpr.evaluate("a * m1")
            else:
                a = a * -1
        else:
            a *= -1.0
        return a
</div>
<div class="viewcode-block" id="GGCMGrid.mhd2gse_field_vector"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid.mhd2gse_field_vector">[docs]</a>    def mhd2gse_field_vector(self, fld, arr):
        layout = fld.layout
        if layout == field.LAYOUT_INTERLACED:
            a = np.array(arr[:, ::-1, ::-1, :], copy=False)
            factor = np.array([-1.0, -1.0, 1.0],
                              dtype=arr.dtype).reshape(1, 1, 1, -1)
        elif layout == field.LAYOUT_FLAT:
            a = np.array(arr[:, :, ::-1, ::-1], copy=False)
            factor = np.array([-1.0, -1.0, 1.0],
                              dtype=arr.dtype).reshape(-1, 1, 1, 1)
        else:
            raise RuntimeError("well what am i looking at then...")

        if self.copy_on_transform:
            if _has_numexpr:
                a = numexpr.evaluate("arr * factor")
            else:
                a = a * factor
        else:
            a *= factor
        return a
</div>
<div class="viewcode-block" id="GGCMGrid.mhd2gse_crds"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid.mhd2gse_crds">[docs]</a>    def mhd2gse_crds(self, crds, arr):  # pylint: disable=W0613
        return np.array(-1.0 * arr[::-1], copy=self.copy_on_transform)
</div>
<div class="viewcode-block" id="GGCMGrid.set_crds"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid.set_crds">[docs]</a>    def set_crds(self, crds_object):
        if self.mhd_to_gse_on_read:
            transform_dict = {}
            transform_dict['y'] = self.mhd2gse_crds
            transform_dict['x'] = self.mhd2gse_crds
            crds_object.transform_funcs = transform_dict
        super(GGCMGrid, self).set_crds(crds_object)
</div>
<div class="viewcode-block" id="GGCMGrid.add_field"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMGrid.add_field">[docs]</a>    def add_field(self, *fields):
        for f in fields:
            if self.mhd_to_gse_on_read:
                # what a pain... vector components also need to be flipped
                if f.name in self._flip_vect_comp_names:
                    f.post_reshape_transform_func = self.mhd2gse_field_scalar_m1
                elif f.name in self._flip_vect_names:
                    f.post_reshape_transform_func = self.mhd2gse_field_vector
                else:
                    f.post_reshape_transform_func = self.mhd2gse_field_scalar
                f.info["crd_system"] = "gse"
            else:
                f.info["crd_system"] = "mhd"
        super(GGCMGrid, self).add_field(*fields)
</div>
    def _get_T(self):
        pp = self["pp"]
        rr = self["rr"]
        T = pp / rr
        T.name = "T"
        T.pretty_name = "T"
        return T

    def _get_bx(self):
        return self['b'].component_fields()[0]

    def _get_by(self):
        return self['b'].component_fields()[1]

    def _get_bz(self):
        return self['b'].component_fields()[2]

    def _get_vx(self):
        return self['v'].component_fields()[0]

    def _get_vy(self):
        return self['v'].component_fields()[1]

    def _get_vz(self):
        return self['v'].component_fields()[2]

    def _assemble_vector(self, base_name, comp_names="xyz", forget_source=True,
                         **kwargs):

        opts = dict(forget_source=forget_source, **kwargs)

        if len(comp_names) == 3:
            with self[base_name + comp_names[0]] as vx, \
                 self[base_name + comp_names[1]] as vy, \
                 self[base_name + comp_names[2]] as vz:
                 v = field.scalar_fields_to_vector(base_name, [vx, vy, vz],
                                                   **opts)
        else:
            comps = [self[base_name + c] for c in comp_names]
            v = field.scalar_fields_to_vector(base_name, comps, **opts)
            for comp in comps:
                comp.unload()
        return v

    def _get_b(self):
        return self._assemble_vector("b", _force_layout=self.force_vector_layout,
                                     pretty_name="B")

    def _get_v(self):
        return self._assemble_vector("v", _force_layout=self.force_vector_layout,
                                     pretty_name="V")

    def _get_e(self):
        return self._assemble_vector("e", _force_layout=self.force_vector_layout,
                                     pretty_name="E")

    def _get_j(self):
        return self._assemble_vector("j", _force_layout=self.force_vector_layout,
                                     pretty_name="J")

    @staticmethod
    def _calc_mag(vx, vy, vz):
        if _has_numexpr:
            vmag = numexpr.evaluate("sqrt(vx**2 + vy**2 + vz**2)")
            return vx.wrap(vmag, typ="Scalar")
        else:
            vmag = np.sqrt(vx**2 + vy**2 + vz**2)
            return vmag

    def _get_bmag(self):
        bx, by, bz = self['bx'], self['by'], self['bz']
        bmag = self._calc_mag(bx, by, bz)
        bmag.name = "|B|"
        return bmag

    def _get_jmag(self):
        jx, jy, jz = self['jx'], self['jy'], self['jz']
        jmag = self._calc_mag(jx, jy, jz)
        jmag.name = "|J|"
        return jmag

    def _get_speed(self):
        vx, vy, vz = self['vx'], self['vy'], self['vz']
        speed = self._calc_mag(vx, vy, vz)
        speed.name = "Speed"
        return speed

    def _get_beta(self):
        return plasma.calc_beta(self['pp'], self['b'])

    def _get_psi(self):
        B = self['b']
        # try to guess if a dim of a 3D field is invariant
        if B.nr_sdims &gt; 2:
            slcs = [slice(None)] * B.nr_sdims
            for i, nxi in enumerate(B.sshape):
                if nxi &lt;= 2:
                    slcs[i] = 0
            B = B[slcs]
        return plasma.calc_psi(B)

</div>
<div class="viewcode-block" id="GGCMFile"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMFile">[docs]</a>class GGCMFile(xdmf.FileXDMF):  # pylint: disable=W0223
    _detector = r"^\s*(.*)\.(p[xyz]_[0-9]+|3d|3df)" \
                r"(\.[0-9]{6})?\.(xmf|xdmf)\s*$"
    _grid_type = GGCMGrid

<div class="viewcode-block" id="GGCMFile.load"><a class="viewcode-back" href="../../../viscid.readers.html#viscid.readers.openggcm.GGCMFile.load">[docs]</a>    def load(self, fname):
        super(GGCMFile, self).load(fname)
        basename = os.path.basename(self.fname)
        self.info['run'] = re.match(self._detector, basename).group(1)

##
## EOF
##</div></div>
</pre>

          <footer>
  <hr/>

  <p>
      &copy; Copyright 2013, Kristofor Maynard.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://www.readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>
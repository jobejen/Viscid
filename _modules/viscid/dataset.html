

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>viscid.dataset &mdash; Viscid 0.60.2 dev documentation</title>
  

  
  

  
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../',
        VERSION:'0.60.2 dev',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="Viscid 0.60.2 dev documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../index.html" class="icon icon-home"> Viscid</a>
        <form class="wy-form" action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#standard-setup">Standard Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#for-developers">For Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">Philosophy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../philosophy.html#data-abstraction">Data Abstraction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../custom_behavior.html">Custom Behavior (rc file)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../custom_behavior.html#common-customizations">Common Customizations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../custom_behavior.html#viscid-grid-grid">viscid.grid.Grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../custom_behavior.html#viscid-readers-openggcm-ggcmgrid">viscid.readers.openggcm.GGCMGrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../custom_behavior.html#viscid-readers-openggcm-ggcmfile">viscid.readers.openggcm.GGCMFile</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_reader.html">Reading/Plotting Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#super-simple">Super Simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#two-plots-one-figure">Two Plots, One Figure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#playing-with-time">Playing with Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#slicing-fields">Slicing Fields</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_openggcm.html">OpenGGCM Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ex_openggcm.html#gse-coordinates">GSE coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_openggcm.html#ionosphere-files">Ionosphere Files</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_calc.html">Calculator Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ex_calc.html#streamlines">Streamlines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line.html">Command Line Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../command_line.html#p2d">p2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line.html#viscid-diff">viscid_diff</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line.html#bitmaskbits">bitmaskbits</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../viscid.html">viscid package</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">Viscid</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../../index.html">Docs</a> &raquo;</li>
  <li><a href="">viscid.dataset</a></li>
  
</ul>
<hr/>

          
  <h1>Source code for viscid.dataset</h1><pre>
#!/usr/bin/env python
""" test docstring """

from __future__ import print_function
# import bisect

import numpy as np

from viscid import logger
from viscid.bucket import Bucket
from viscid.vutil import tree_prefix

<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset">[docs]</a>class Dataset(object):
    """ datasets contain grids or other datasets
    (GridCollection derrives from Dataset)
    It is the programmer's responsibility to ensure objects added to a AOEUIDH
    dataset have __getitem__ and get_fields methods, this is not
    enforced
    """
    name = None
    time = None
    children = None  # Bucket or (time, grid)
    active_child = None

    topology_info = None
    geometry_info = None
    crds = None

    info = None

    def __init__(self, name, time=None):
        self.name = name
        self.children = Bucket()

        self.active_child = None
        self.time = time
        self.info = {}

<div class="viewcode-block" id="Dataset.add"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.add">[docs]</a>    def add(self, child, set_active=True):
        self.children[child.name] = child
        if set_active:
            self.active_child = child
</div>
<div class="viewcode-block" id="Dataset.unload"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.unload">[docs]</a>    def unload(self):
        """ unload is meant to give children a chance to free caches, the idea
        being that an unload will free memory, but all the functionality is
        preserved, so data is accessable without an explicit reload
        """
        for child in self.children:
            child.unload()
        # TODO: does anything else need to be unloaded in here?

    # def remove_all_items(self):
    #     raise NotImplementedError()
</div>
<div class="viewcode-block" id="Dataset.activate"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.activate">[docs]</a>    def activate(self, child_handle):
        """ it may not look like it, but this will recursively look
        in my active child for the handle because it uses getitem """
        self.active_child = self.children[child_handle]
</div>
<div class="viewcode-block" id="Dataset.activate_time"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.activate_time">[docs]</a>    def activate_time(self, time):
        """ this is basically 'activate' except it specifically picks out
        temporal datasets, and does all children, not just the active child """
        for child in self.children:
            try:
                child.activate_time(time)
            except AttributeError:
                pass
</div>
<div class="viewcode-block" id="Dataset.nr_times"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.nr_times">[docs]</a>    def nr_times(self, slice_str=":"):
        for child in self.children:
            try:
                return child.nr_times(slice_str)
            except AttributeError:
                pass
        raise RuntimeError("I find no temporal datasets")
</div>
<div class="viewcode-block" id="Dataset.iter_times"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.iter_times">[docs]</a>    def iter_times(self, slice_str=":"):
        for child in self.children:
            try:
                return child.iter_times(slice_str)
            except AttributeError:
                pass
        raise RuntimeError("I find no temporal datasets")
</div>
<div class="viewcode-block" id="Dataset.iter_fields"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.iter_fields">[docs]</a>    def iter_fields(self, time=None, named=None):
        """ generator for fields in the active dataset,
        this will recurse down to a grid """
        child = self.active_child

        if child is None:
            logger.warn("Could not get appropriate child...")
            return None
        else:
            return child.iter_fields(time=time, named=named)
</div>
<div class="viewcode-block" id="Dataset.print_tree"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.print_tree">[docs]</a>    def print_tree(self, depth=-1, prefix=""):
        if prefix == "":
            print(self)
            prefix += tree_prefix

        for child in self.children:
            suffix = ""
            if child is self.active_child:
                suffix = " &lt;-- active"
            print("{0}{1}{2}".format(prefix, child, suffix))
            if depth != 0:
                child.print_tree(depth=depth - 1, prefix=prefix + tree_prefix)

    # def get_non_dataset(self):
    #     """ recurse down datasets until active_grid is not a subclass
    #         of Dataset """
    #     if isinstance(self.activate_grid, Dataset):
    #         return self.active_grid.get_non_dataset()
    #     else:
    #         return self.active_grid
</div>
<div class="viewcode-block" id="Dataset.get_field"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.get_field">[docs]</a>    def get_field(self, fldname, time=None):
        """ recurse down active children to get a field """
        child = self.active_child

        if child is None:
            logger.warn("Could not get appropriate child...")
            return None
        else:
            return child.get_field(fldname, time=time)
</div>
<div class="viewcode-block" id="Dataset.get_grid"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.get_grid">[docs]</a>    def get_grid(self, time=None):
        """ recurse down active children to get a field """
        child = self.active_child

        if child is None:
            logger.warn("Could not get appropriate child...")
            return None
        else:
            return child.get_grid(time=time)
</div>
<div class="viewcode-block" id="Dataset.get_child"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.get_child">[docs]</a>    def get_child(self, item):
        """ get a child from this Dataset,  """
        return self.children[item]
</div>
<div class="viewcode-block" id="Dataset.__getitem__"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.Dataset.__getitem__">[docs]</a>    def __getitem__(self, item):
        """ if a child exists with handle, return it, else ask
        the active child if it knows what you want """
        if item in self.children:
            return self.get_child(item)
        elif self.active_child is not None:
            return self.active_child[item]
        else:
            raise KeyError()
</div>
    def __delitem__(self, item):
        child = self.get_child(item)
        child.unload()
        self.children.remove_item(child)

    def __len__(self):
        return self.children.__len__()

    def __setitem__(self, name, child):
        # um... is this kosher??
        child.name = name
        self.add(child)

    def __contains__(self, item):
        if item in self.children:
            return True
        # FIXME: this might cause a bug somewhere someday
        if item in self.active_child:
            return True
        return False

    def __enter__(self):
        return self

    def __exit__(self, typ, value, traceback):
        self.unload()
        return None

    # def __iter__(self):
    #     for child in self.children:
    #         yield child

    # def __next__(self):
    #     raise NotImplementedError()

</div>
<div class="viewcode-block" id="DatasetTemporal"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal">[docs]</a>class DatasetTemporal(Dataset):
    _last_ind = 0
    # _all_times = None

    def __init__(self, name, time=None):
        super(DatasetTemporal, self).__init__(name, time=time)
        # ok, i want more control over my childen than a bucket can give
        # TODO: it's kind of a kludge to create a bucket then destroy it
        # so soon, but it's not a big deal
        self.children = []
        # self._all_times = []

<div class="viewcode-block" id="DatasetTemporal.add"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.add">[docs]</a>    def add(self, child, set_active=True):
        if child is None:
            raise RuntimeError()
        if child.time is None:
            child.time = 0.0
            logger.warn("A child with no time? Something is strange...")
        # this keeps the children in time order
        self.children.append((child.time, child))
        self.children.sort()
        # binary in sorting... maybe more efficient?
        #bisect.insort(self.children, (child.time, child))
        if set_active:
            self.active_child = child
</div>
<div class="viewcode-block" id="DatasetTemporal.unload"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.unload">[docs]</a>    def unload(self):
        """ unload is meant to give children a chance to free caches, the idea
        being that an unload will free memory, but all the functionality is
        preserved, so data is accessable without an explicit reload
        """
        for child in self.children:
            child[1].unload()
        # TODO: does anything else need to be unloaded in here?
</div>
<div class="viewcode-block" id="DatasetTemporal.activate"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.activate">[docs]</a>    def activate(self, time):
        self.active_child = self.get_child(time)
</div>
<div class="viewcode-block" id="DatasetTemporal.activate_time"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.activate_time">[docs]</a>    def activate_time(self, time):
        """ this is basically 'activate' except it specifically picks out
        temporal datasets """
        self.activate(time)
</div>
    def _slice_time(self, slice_str=":"):
        times = np.array([child[0] for child in self.children])
        slc_lst = [s.strip() for s in slice_str.split(":")]

        if len(slc_lst) == 1:
            s = slc_lst[0]

            # i'm not keen on the whole ij thing since it makes
            # arr["1"] different from arr[1], i think i prefer to
            # require arr["1.0"] to slice by a float value
            # if s[-1] in "ij":
            #     slc = int(s[:-1])
            # else:
            #     slc = np.argmin(np.abs(float(s) - times))

            try:
                slc = int(s)
            except ValueError:
                slc = np.argmin(np.abs(float(s) - times))
        else:
            for i, s in enumerate(slc_lst):
                if s == "":
                    slc_lst[i] = None
                else:
                    try:
                        slc_lst[i] = int(s)
                    except ValueError:
                        slc_lst[i] = np.argmin(np.abs(float(s) - times))

            # make the slice inclusive, no matter what
            if slc_lst[1] is not None:
                if slc_lst[0] &lt;= slc_lst[1]:
                    slc_lst[1] += 1
                else:
                    slc_lst[1] -= 1

            slc = slice(*slc_lst)

        # otherwise the slice would reduce the dimension, which isn't what
        # we want in iter_times
        if isinstance(slc, int):
            if slc == -1:
                slc = slice(-1, None)
            else:
                slc = slice(slc, slc + 1)

        # print("time slc list:", slc_lst, slc)

        return slc

<div class="viewcode-block" id="DatasetTemporal.nr_times"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.nr_times">[docs]</a>    def nr_times(self, slice_str=":"):
        slc = self._slice_time(slice_str=slice_str)
        return len(self.children[slc])
</div>
<div class="viewcode-block" id="DatasetTemporal.iter_times"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.iter_times">[docs]</a>    def iter_times(self, slice_str=":"):
        slc = self._slice_time(slice_str=slice_str)
        for child in self.children[slc]:
            with child[1] as target:
                yield target
        # this old way lead to a 'memory leak' of sorts
        # return (child[1] for child in self.children[slc])
</div>
<div class="viewcode-block" id="DatasetTemporal.iter_fields"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.iter_fields">[docs]</a>    def iter_fields(self, time=None, named=None):
        """ generator for fields in the active dataset,
        this will recurse down to a grid """
        if time is not None:
            child = self.get_child(time)
        else:
            child = self.active_child

        if child is None:
            logger.warn("Could not get appropriate child...")
            return None
        else:
            return child.iter_fields(time=time, named=named)
</div>
<div class="viewcode-block" id="DatasetTemporal.print_tree"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.print_tree">[docs]</a>    def print_tree(self, depth=-1, prefix=""):
        if prefix == "":
            print(self)
            prefix += tree_prefix

        for child in self.children:
            suffix = ""
            if child[1] is self.active_child:
                suffix = " &lt;-- active"
            print("{0}{1} (t={2}){3}".format(prefix, child, child[0], suffix))
            if depth != 0:
                child[1].print_tree(depth=depth - 1, prefix=prefix + tree_prefix)
</div>
<div class="viewcode-block" id="DatasetTemporal.get_field"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.get_field">[docs]</a>    def get_field(self, fldname, time=None):
        """ recurse down active children to get a field """
        if time is not None:
            child = self.get_child(time)
        else:
            child = self.active_child

        if child is None:
            logger.warn("Could not get appropriate child...")
            return None
        else:
            return child.get_field(fldname, time=time)
</div>
<div class="viewcode-block" id="DatasetTemporal.get_grid"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.get_grid">[docs]</a>    def get_grid(self, time=None):
        """ recurse down active children to get a field """
        if time is not None:
            child = self.get_child(time)
        else:
            child = self.active_child

        if child is None:
            logger.warn("Could not get appropriate child...")
            return None
        else:
            return child.get_grid(time=time)
</div>
<div class="viewcode-block" id="DatasetTemporal.get_child"><a class="viewcode-back" href="../../viscid.html#viscid.dataset.DatasetTemporal.get_child">[docs]</a>    def get_child(self, item):
        """ if item is an int and &lt; len(children), it is an index in a list,
        else I will find the cloest time to float(item) """
        if len(self.children) &lt;= 1:
            # it's appropriate to get an index error if len == 0
            self._last_ind = 0
            return self.children[0][1]
        elif isinstance(item, int) and item &lt; len(self.children):
            #print('integering')
            self._last_ind = item
            return self.children[item][1]
        else:
            # NOTE: this has gone too far
            time = float(item)
            last_ind = self._last_ind
            closest_ind = -1
            # print(time, last_ind)
            if time &gt;= self.children[last_ind][0]:
                # print("forward")
                i = last_ind + 1
                while i &lt; len(self.children):
                    this_time = self.children[i][0]
                    # print(i, this_time)
                    if time &lt;= this_time:
                        avg = 0.5 * (self.children[i - 1][0] + this_time)
                        if time &gt;= avg:
                            # print("&gt;= ", avg)
                            closest_ind = i
                        else:
                            # print("&lt; ", avg)
                            closest_ind = i - 1
                        break
                    i += 1
                if closest_ind &lt; 0:
                    closest_ind = len(self.children) - 1
            else:
                # print("backward")
                i = last_ind - 1
                while i &gt;= 0:
                    this_time = self.children[i][0]
                    # print(i, this_time)
                    if time &gt;= self.children[i][0]:
                        avg = 0.5 * (self.children[i + 1][0] + this_time)
                        if time &gt;= avg:
                            # print("&gt;= ", avg)
                            closest_ind = i + 1
                        else:
                            # print("&lt; ", avg)
                            closest_ind = i
                        break
                    i -= 1
                if closest_ind &lt; 0:
                    closest_ind = 0
            # print("closest_ind: ", closest_ind)
            self._last_ind = closest_ind
            return self.children[closest_ind][1]
</div>
    def __contains__(self, item):
        if isinstance(item, int) and item &lt; len(self.children):
            return True
        try:
            float(item)
            return True
        except ValueError:
            return item in self.active_child

    # def __getitem__(self, item):
    #     """ Get a dataitem or list of dataitems based on time, grid, and
    #         varname. the 'active' components are given by default, but varname
    #         is manditory, else how am i supposed to know what to serve up for
    #         you. Examples:
    #         dataset[time, 'gridhandle', 'varname'] == DataItem
    #         dataset['time', 'gridhandle', 'varname'] == DataItem
    #         dataset[timeslice, 'gridhandle', 'varname'] == list of DataItems
    #         dataset[time, 'varname'] == DataItem using active grid
    #         dataset['varname'] == DataItem using active time / active grid
    #         """
    #     req_grid = None

    #     if not isinstance(item, tuple):
    #         item = (item,)

    #     varname = item[-1]
    #     nr_times = len(item) - 1 # -1 for varname
    #     try:
    #         if len(item) &gt; 1:
    #             req_grid = self.grids[item[-2]]
    #     except KeyError:
    #         pass
    #     if not req_grid:
    #         req_grid = self.active_grid
    #         nr_times -= 1

    #     if nr_times == 0:
    #         grids = [self.grid_by_time(self.active_time)]
    #     else:
    #         grids = [self.grid_by_time(t) for t in item[:nr_times]]

    #     if len(grids) == 1:
    #         return grids[0][varname]
    #     else:
    #         return [g[varname] for g in grids]

    # def grid_by_time(self, time):
    #     """ returns grid for this specific time, time can also be a slice """
    #     if isinstance(time, slice):
    #         pass
    #     else:
    #         pass</div>
</pre>

          <footer>
  <hr/>

  <p>
      &copy; Copyright 2013, Kristofor Maynard.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://www.readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>
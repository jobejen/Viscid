<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>viscid.plot.mpl &mdash; Viscid 0.50.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.50.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Viscid 0.50.2 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Viscid 0.50.2 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for viscid.plot.mpl</h1><pre>
#!/usr/bin/env python

from __future__ import print_function
import logging
from distutils.version import LooseVersion

import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize, LogNorm
from mpl_toolkits.mplot3d import Axes3D #pylint: disable=W0611

from .. import field
from ..calculator import calc
from ..calculator.topology import color_from_topology
# from .. import vutil

__mpl_ver__ = matplotlib.__version__
has_colorbar_gridspec = LooseVersion(__mpl_ver__) &gt; LooseVersion("1.1.1")

<div class="viewcode-block" id="plot"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot">[docs]</a>def plot(fld, selection=None, **kwargs):
    """ just plot... should generically dispatch to gen the right
    matplotlib plot given the field. returns the mpl plot and color bar
    as a tuple """
    if isinstance(fld, field.ScalarField):
        fld = fld.slice_reduce(selection)

        if fld.nr_sdims == 1:
            return plot1d_field(fld, **kwargs)
        elif fld.nr_sdims == 2:
            return plot2d_field(fld, **kwargs)
        else:
            raise ValueError("mpl can only do 1-D or 2-D fields")
    else:
        raise TypeError("I can only do scalar fields right now")
</div>
def _parse_str(plot_opts):
    """ opts string looks like 'log,x=-20_10', output is
    [['log'], ['x', '-20', '10']] """

    if isinstance(plot_opts, str):
        plot_opts = plot_opts.split(",")
    elif plot_opts is None:
        plot_opts = []

    for i, opt in enumerate(plot_opts):
        if isinstance(opt, str):
            plot_opts[i] = opt.replace("=", "_").split("_")
        elif not isinstance(plot_opts[i], (list, tuple)):
            plot_opts[i] = [plot_opts[i]]

    return plot_opts

def _apply_parse_opts(plot_opts_str, fld, kwargs, axis=None):
    """ modifies kwargs and returns a list of things to set after the fact
    kwargs are things that get added as arguments to the plot command
    plot_acts are set using plt.set(act[0], act[1], act[2]) """

    plot_opts = _parse_str(plot_opts_str)
    # acts = []

    if not axis:
        axis = plt.gca()

    for opt in plot_opts:
        if opt[0] == "lin":
            opt = [float(o) if i &gt; 0 else o for i, o in enumerate(opt)]
            axis.set_xscale("linear")
            axis.set_yscale("linear")

            # scale will be centered around 0
            if len(opt) == 2 and float(opt[1]) == 0.0:
                absmax = calc.abs_max(fld)
                opt = [opt[0], -1.0 * absmax, 1.0 * absmax]

            if fld.nr_sdims == 1:
                axis.set_ylim(*opt[1:])
            elif fld.nr_sdims == 2:
                # plt.normalize is deprecated
                # kwargs["norm"] = plt.normalize(*opt[1:])
                kwargs["norm"] = Normalize(*opt[1:])

        elif opt[0] == "log":
            opt = [float(o) if i &gt; 0 else o for i, o in enumerate(opt)]
            axis.set_xscale("linear")

            if fld.nr_sdims == 1:
                axis.set_yscale("log")
                axis.set_ylim(*opt[1:])
            elif fld.nr_sdims == 2:
                axis.set_yscale("linear")
                kwargs["norm"] = LogNorm(*opt[1:])

        elif opt[0] == "loglog":
            opt = [float(o) if i &gt; 0 else o for i, o in enumerate(opt)]
            axis.set_xscale("log")
            axis.set_yscale("log")
            if fld.nr_sdims == 2:
                kwargs["norm"] = LogNorm(*opt[1:])

        elif opt[0] in ["g", "grid"]:
            kwargs["edgecolors"] = 'k'
            kwargs["linewidths"] = 0.2
            kwargs["antialiased"] = True

        elif opt[0] == "x":
            opt = [float(o) if i &gt; 0 else o for i, o in enumerate(opt)]
            axis.set_xlim(*opt[1:])
            # acts.append([axis, "xlim", opt[1:]])

        elif opt[0] == "y":
            opt = [float(o) if i &gt; 0 else o for i, o in enumerate(opt)]
            axis.set_ylim(*opt[1:])
            # acts.append([axis, "ylim", opt[1:]])

        elif opt[0] == "earth":
            kwargs["earth"] = True

        elif opt[0] == "own":
            logging.warn("own axis doesn't seem to work yet...")

        elif opt[0] == "ownx":
            logging.warn("own axis doesn't seem to work yet...")

        elif opt[0] == "owny":
            logging.warn("own axis doesn't seem to work yet...")

        else:
            logging.warn("Unknown plot option ({0})".format(opt[0]))

    # things that i just want to be automagic...
    # use seismic cmap if the data looks centered around 0
    if "norm" in kwargs and "cmap" not in kwargs:
        norm = kwargs["norm"]
        if norm.vmin and norm.vmax and np.abs(norm.vmax + 1.0*norm.vmin) &lt; 1e-4:
            kwargs["cmap"] =  plt.get_cmap('seismic')

    # return axis, acts
    return axis

# def _apply_acts(acts):
#     for act in acts:
#         print(act)
#         plt.setp(act[0], act[1], act[2])

<div class="viewcode-block" id="plot2d_field"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot2d_field">[docs]</a>def plot2d_field(fld, style="pcolormesh", ax=None, equalaxis=True,
                 show=False, mask_nan=False, mod=None, plot_opts=None,
                 colorbar=True, rotate_plot=False, label_cbar=True,
                 action_ax=None, extra_args=[], **kwargs):
    """ Plot a 2D Field using pcolormesh or contour or something like that...

    style: "pcolormesh", "contour", "pcolor", style of 2D plot
    ax: axis to plot in (plt.gca() used if not specified)
    equalaxis: whether or not the plot will enforce equal aspect ratio
    earth: whether or not to plot
    show: call mpl.show() afterward
    mask_nan: mask nan values in fld.data
    mod: list of scaling factors for the coords
    plot_opts: string of options
    colorbar: is evaluated boolean to decide whether to plot a colorbar, if
    it is a dict, it's passed to colorbar as keyword args
    (note: bool({}) == False) """
    if fld.nr_sdims != 2:
        raise RuntimeError("I will only contour a 2d field")

    # THIS IS BACKWARD, on account of the convention for
    # Coordinates where z, y, x is used since that is how
    # xdmf data is
    namey, namex = fld.crds.axes # fld.crds.get_culled_axes()

    # pcolor mesh uses node coords, and cell data, if we have
    # node data, fake it by using cell centered coords and
    # trim the edges of the data... maybe i should just be
    # extapolating the crds and keeping the edges...
    if style in ["pcolormesh", "pcolor"]:
        if fld.iscentered("Node"):
            X, Y = fld.get_crds_cc((namex, namey))
            # extrapolate the crds to plot the boundary cells
            dx = X[1:] - X[:-1]
            X = np.concatenate([[X[0] - dx[0]], X, [X[-1] + dx[-1]]])
            dy = Y[1:] - Y[:-1]
            Y = np.concatenate([[Y[0] - dy[0]], Y, [Y[-1] + dy[-1]]])
        elif fld.iscentered("Cell"):
            X, Y = fld.get_crds_nc((namex, namey))
    else:
        if fld.iscentered("Node"):
            X, Y = fld.get_crds_nc((namex, namey))
        elif fld.iscentered("Cell"):
            X, Y = fld.get_crds_cc((namex, namey))
    dat = fld.data

    if mod:
        X *= mod[0]
        Y *= mod[1]

    # print(x.shape, y.shape, fld.data.shape)
    if mask_nan:
        dat = np.ma.masked_where(np.isnan(dat), dat)

    if not ax:
        ax = plt.gca()
    if equalaxis:
        ax.axis('equal')
    ax = _apply_parse_opts(plot_opts, fld, kwargs, ax)
    if action_ax is None:
        action_ax = ax

    earth = kwargs.pop("earth", False)

    if rotate_plot:
        X, Y = Y.T, X.T
        dat = dat.T
        namex, namey = namey, namex

    if style == "pcolormesh":
        p = action_ax.pcolormesh(X, Y, dat, *extra_args, **kwargs)
    elif style == "contour":
        p = action_ax.contour(X, Y, dat, *extra_args, **kwargs)
        if "colors" in kwargs:
            colorbar = False
    elif style == "contourf":
        p = action_ax.contourf(X, Y, dat, *extra_args, **kwargs)
    elif style == "pcolor":
        p = action_ax.pcolor(X, Y, dat, *extra_args, **kwargs)
    else:
        raise RuntimeError("I don't understand {0} 2d plot style".format(style))

    # figure out the colorbar...
    if colorbar:
        if not isinstance(colorbar, dict):
            colorbar = {}
        # unless otherwise specified, use_gridspec for
        if has_colorbar_gridspec and not "use_gridspec" in colorbar:
            colorbar["use_gridspec"] = True
        # ok, this way to pass options to colorbar is bad!!!
        # but it's kind of the cleanest way to affect the colorbar?
        cbar = plt.colorbar(p, **colorbar) #pylint: disable=W0142
        if label_cbar:
            cbar.set_label(fld.pretty_name)
    else:
        cbar = None

    plt.xlabel(namex)
    plt.ylabel(namey)

    # _apply_acts(acts)

    if earth:
        plot_earth(fld)
    if show:
        mplshow()
    return p, cbar
</div>
<div class="viewcode-block" id="plot1d_field"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot1d_field">[docs]</a>def plot1d_field(fld, ax=None, plot_opts=None, show=False, **kwargs):
    namex, = fld.crds.axes
    if fld.iscentered("Node"):
        x = fld.get_crd_nc(namex)
    elif fld.iscentered("Cell"):
        x = fld.get_crd_cc(namex)

    ax = _apply_parse_opts(plot_opts, fld, kwargs, ax)
    p = plt.plot(x, fld.data, **kwargs)
    plt.xlabel(namex)
    plt.ylabel(fld.pretty_name)
    # _apply_acts(acts)

    if show:
        mplshow()
    return p, None
</div>
<div class="viewcode-block" id="plot_streamlines"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot_streamlines">[docs]</a>def plot_streamlines(lines, topology=None, ax=None, show=True, equal=False,
                     **kwargs):
    if not ax:
        ax = plt.gca(projection='3d')

    if "color" not in kwargs and topology is not None:
        if isinstance(topology, field.Field):
            topology = topology.data.reshape(-1)
        topo_color = True
    else:
        topo_color = False

    for i, line in enumerate(lines):
        line = np.array(line, copy=False)
        z = line[0]
        y = line[1]
        x = line[2]

        if topo_color:
            kwargs["color"] = color_from_topology(topology[i])
        p = ax.plot(x, y, z, **kwargs)
    if equal:
        ax.axis("equal")
    plt.xlabel("x")
    plt.ylabel("y")
    if show:
        plt.show()
    return p, None
</div>
<div class="viewcode-block" id="plot_streamlines2d"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot_streamlines2d">[docs]</a>def plot_streamlines2d(lines, symmetry_dir, topology=None, ax=None, show=False,
                       equal=False, rotate_plot=False, **kwargs):
    """ print streamlines given as a list of lines which are ndarrays with
    dimension (3, npts). symmetry_dir says which dimension to ignore, so that
    the lines are just parallel projected onto a plane. kwargs are passed to
    plt.plot(...). topology can be an integer array (or field) of
    size = nr_lines to color the lines by topology """
    if not ax:
        ax = plt.gca()
    p = None

    if topology is not None:
        if isinstance(topology, field.Field):
            topology = topology.data.reshape(-1)
        if not "color" in kwargs:
            topo_color = True
    else:
        topo_color = False

    for i, line in enumerate(lines):
        line = np.array(line, copy=False)
        if symmetry_dir.lower() == "x":
            x = line[1]
            y = line[0]
        elif symmetry_dir.lower() == "y":
            x = line[2]
            y = line[0]
        elif symmetry_dir.lower() == "z":
            x = line[2]
            y = line[1]
        else:
            raise ValueError("symmetry_dir should be x, y, or z")

        if rotate_plot:
            x, y = y, x

        if topo_color:
            kwargs["color"] = color_from_topology(topology[i])
        p = ax.plot(x, y, **kwargs)

    if show:
        plt.show()
    return p, None
</div>
<div class="viewcode-block" id="plot2d_quiver"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot2d_quiver">[docs]</a>def plot2d_quiver(fld, symdir, downscale=1, **kwargs):
    # FIXME: with dowscale != 1, this reveals a problem when slice and
    # downscaling a field; i think this is a prickley one
    vx, vy, vz = fld.component_views()
    x, y = fld.get_crds_cc(shaped=True)
    if symdir.lower() == "x":
        # x, y = ycc, zcc
        pvx, pvy = vy, vz
    elif symdir.lower() == "y":
        # x, y = xcc, zcc
        pvx, pvy = vx, vz
    elif symdir.lower() == "z":
        # x, y = xcc, ycc
        pvx, pvy = vx, vy
    X, Y = np.meshgrid(y, x)
    if downscale != 1:
        X = X[::downscale]
        Y = Y[::downscale]
        pvx = pvx[::downscale]
        pvy = pvy[::downscale]
    # print(X.shape, Y.shape, pvx.shape, pvy.shape)
    return plt.quiver(X, Y, pvx, pvy, **kwargs)
</div>
<div class="viewcode-block" id="scatter_3d"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.scatter_3d">[docs]</a>def scatter_3d(points, c='b', ax=None, show=True, equal=False, **kwargs):
    """ c should be an array of values to use to color the points,
    a la pyplot.scatter """
    if not ax:
        ax = plt.gca(projection='3d')

    z = points[0]
    y = points[1]
    x = points[2]
    p = ax.scatter(x, y, z, c=c, **kwargs)
    if equal:
        ax.axis("equal")
    plt.xlabel("x")
    plt.ylabel("y")
    if show:
        plt.show()
    return p, None

</div>
<div class="viewcode-block" id="mplshow"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.mplshow">[docs]</a>def mplshow():
    # do i need to do anything special before i show?
    # can't think of anything at this point...
    plt.show()
</div>
<div class="viewcode-block" id="tighten"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.tighten">[docs]</a>def tighten():
    """ tightens the layout so that axis labels dont get plotted over """
    try:
        plt.tight_layout()
    except AttributeError:
        logging.warn("No matplotlib tight layout support")
</div>
<div class="viewcode-block" id="plot_earth"><a class="viewcode-back" href="../../../viscid.plot.html#viscid.plot.mpl.plot_earth">[docs]</a>def plot_earth(fld, axis=None, scale=1.0, rot=0,
               daycol='w', nightcol='k', crd_system="mhd"):
    """ crd_system = "mhd" (Jimmy crds) or "gse" (GSE crds)... gsm is the
    same as mhd + rot=180. This is inferred from fld but defaults to whatever
    is given. earth_plane is a string in the format 'y=0.2', this
    says what the 3rd.nr_sdimsension is and sets the radius that the earth
    should be """
    import matplotlib.patches as mpatches

    crd_system = fld.info.get("crd_system", crd_system)

    # take only the 1st reduced.nr_sdims... this should just work
    try:
        plane, value = fld.deep_meta["reduced"][0]
    except KeyError:
        logging.error("No reduced dims in the field, i don't know what 2d \n "
                      "plane, we're in and can't figure out the size of earth.")
        return None

    if value**2 &gt;= scale**2:
        return None
    radius = np.sqrt(scale**2 - value**2)

    if not axis:
        axis = plt.gca()

    if crd_system == "gse":
        rot = 180

    if plane == 'y' or plane == 'z':
        axis.add_patch(mpatches.Wedge((0, 0), radius, 90 + rot, 270 + rot,
                                      ec=nightcol, fc=daycol))
        axis.add_patch(mpatches.Wedge((0, 0), radius, 270 + rot, 450 + rot,
                                      ec=nightcol, fc=nightcol))
    elif plane == 'x':
        if value &lt; 0:
            axis.add_patch(mpatches.Circle((0, 0), radius, ec=nightcol,
                                           fc=daycol))
        else:
            axis.add_patch(mpatches.Circle((0, 0), radius, ec=nightcol,
                                           fc=nightcol))
    return None

##
## EOF
##</div>
</pre>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Viscid 0.50.2 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Kristofor Maynard.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>
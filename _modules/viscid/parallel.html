

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>viscid.parallel &mdash; Viscid 0.60.0 dev documentation</title>
  

  
  

  
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../',
        VERSION:'0.60.0 dev',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="Viscid 0.60.0 dev documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../index.html" class="icon icon-home"> Viscid</a>
        <form class="wy-form" action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#standard-setup">Standard Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#for-developers">For Developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">Philosophy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../philosophy.html#data-abstraction">Data Abstraction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_reader.html">Reading/Plotting Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#super-simple">Super Simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#two-plots-one-figure">Two Plots, One Figure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#playing-with-time">Playing with Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_reader.html#slicing-fields">Slicing Fields</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_openggcm.html">OpenGGCM Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ex_openggcm.html#gse-coordinates">GSE coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ex_openggcm.html#ionosphere-files">Ionosphere Files</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_calc.html">Calculator Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ex_calc.html#streamlines">Streamlines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line.html">Command Line Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../command_line.html#p2d">p2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line.html#viscid-diff">viscid_diff</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line.html#bitmaskbits">bitmaskbits</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../viscid.html">viscid package</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">Viscid</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../../index.html">Docs</a> &raquo;</li>
  <li><a href="">viscid.parallel</a></li>
  
</ul>
<hr/>

          
  <h1>Source code for viscid.parallel</h1><pre>
"""common tools for parallel processing"""

from __future__ import print_function, division
from math import ceil
import multiprocessing as mp
import multiprocessing.pool
from contextlib import closing
from itertools import repeat
try:
    from itertools import izip
except ImportError:
    izip = zip

import numpy as np


# Non daemonic processes are probably a really bad idea
<div class="viewcode-block" id="NoDaemonProcess"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.NoDaemonProcess">[docs]</a>class NoDaemonProcess(mp.Process):
    """Using this is probably a bad idea"""
    # make 'daemon' attribute always return False
    @staticmethod
    def _get_daemon():
        return False
    def _set_daemon(self, value):
        pass
    daemon = property(_get_daemon, _set_daemon)
</div>
<div class="viewcode-block" id="NoDaemonPool"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.NoDaemonPool">[docs]</a>class NoDaemonPool(multiprocessing.pool.Pool): #pylint: disable=W0223
    """ I am vulnerable to armies of undead worker processes, chances
    are you don't actually want to use me
    """
    Process = NoDaemonProcess

</div>
<div class="viewcode-block" id="chunk_list"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.chunk_list">[docs]</a>def chunk_list(seq, nchunks, size=None):
    """Chunk a list

    slice seq into chunks of nchunks size, seq can be a anything
    sliceable such as lists, numpy arrays, etc. These chunks will be
    'contiguous', see :meth:`chunk_interslice` for picking every nth
    element.

    Parameters:
        size: if given, set nchunks such that chunks have about 'size'
            elements

    Returns:
        nchunks slices of length N = (len(lst) // nchunks) or N - 1

    See Also:
        Use :meth:`chunk_iterator` to chunk up iterators

    Example:
        &gt;&gt;&gt; it1, it2, it3 = chunk_list(range(8), 3)
        &gt;&gt;&gt; it1 == range(0, 3)  # 3 vals
        True
        &gt;&gt;&gt; it2 == range(3, 6)  # 3 vals
        True
        &gt;&gt;&gt; it3 == range(6, 8)  # 2 vals
        True
    """
    nel = len(seq)

    if size is not None:
        nchunks = int(ceil(nel / nchunks))

    ret = chunk_slices(nel, nchunks)
    for i in range(nchunks):
        ret[i] = seq[slice(*ret[i])]
    return ret
</div>
<div class="viewcode-block" id="chunk_slices"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.chunk_slices">[docs]</a>def chunk_slices(nel, nchunks, size=None):
    r"""Make continuous chunks

    Get the slice info (can be unpacked and passed to the slice builtin
    as in slice(\*ret[i])) for nchunks contiguous chunks in a list with
    nel elements

    Parameters:
        nel: how many elements are in one pass of the original list
        nchunks: how many chunks to make
        size: if given, set nchunks such that chunks have about 'size'
            elements

    Returns:
        a list of (start, stop) tuples with length nchunks

    Example:
        &gt;&gt;&gt; sl1, sl2 = chunk_slices(5, 2)
        &gt;&gt;&gt; sl1 == (0, 3)  # 3 vals
        True
        &gt;&gt;&gt; sl2 == (3, 5)  # 2 vals
        True
    """
    if size is not None:
        nchunks = int(ceil(nel / nchunks))

    nlong = nel % nchunks  # nshort guarenteed &lt; nchunks
    lenshort = nel // nchunks
    lenlong = lenshort + 1

    ret = [None] * nchunks
    start = 0
    for i in range(nlong):
        ret[i] = (start, start + lenlong)
        start += lenlong
    for i in range(nlong, nchunks):
        ret[i] = (start, start + lenshort)
        start += lenshort
    return ret
</div>
<div class="viewcode-block" id="chunk_interslices"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.chunk_interslices">[docs]</a>def chunk_interslices(nchunks):
    """Make staggered chunks

    Similar to chunk_slices, but pick every nth element instead of
    getting a contiguous block for each chunk

    Parameters:
        nchunks: how many chunks to make

    Returns:
        a list of (start, stop, step) tuples with length nchunks

    Example:
        &gt;&gt;&gt; chunk_slices(2) == [(0, None, 2), (1, None, 2)]
        True
    """
    ret = [None] * nchunks
    for i in range(nchunks):
        ret[i] = (i, None, nchunks)
    return ret
</div>
<div class="viewcode-block" id="chunk_sizes"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.chunk_sizes">[docs]</a>def chunk_sizes(nel, nchunks, size=None):
    """For chunking up lists, how big is each chunk

    Parameters:
        nel: how many elements are in one pass of the original list
        nchunks: is inferred from the length of iter_list
        size: if given, set nchunks such that chunks have about 'size'
            elements
    Returns:
        an ndarray of the number of elements in each chunk, this
        should be the same for chunk_list, chunk_slices and
        chunk_interslices

    Example:
        &gt;&gt;&gt; nel1, nel2 = chunk_sizes(5, 2)
        &gt;&gt;&gt; nel1 == 2
        True
        &gt;&gt;&gt; nel2 == 3
        True
    """
    if size is not None:
        nchunks = int(ceil(nel / nchunks))

    nlong = nel % nchunks  # nshort guarenteed &lt; nchunks
    lenshort = nel // nchunks
    lenlong = lenshort + 1
    ret = np.empty((nchunks,), dtype="int")
    ret[:nlong] = lenlong
    ret[nlong:] = lenshort
    return ret
</div>
def _star_passthrough(args):
    """ this is so we can give a zipped iterable to func """
    # args[0] is function, args[1] is positional args, and args[2] is kwargs
    return args[0](*(args[1]), **(args[2]))

<div class="viewcode-block" id="map"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.map">[docs]</a>def map(nr_procs, func, args_iter, timeout=1e8, daemonic=True, pool=None,
        **kwargs):  # pylint: disable=redefined-builtin
    """Just like ``subprocessing.map``?

    same as :meth:`map_async`, except it waits for the result to
    be ready and returns it
    """
    # don't waste time spinning up a new process
    if nr_procs == 1:
        args_iter = izip(repeat(func), args_iter, repeat(kwargs))
        return [_star_passthrough(args) for args in args_iter]
    else:
        p, r = map_async(nr_procs, func, args_iter, daemonic=daemonic,
                         pool=pool, **kwargs)
        ret = r.get(timeout)
        # in principle this join should return almost immediately since
        # we already called r.get
        p.join()
        return ret
</div>
<div class="viewcode-block" id="map_async"><a class="viewcode-back" href="../../viscid.html#viscid.parallel.map_async">[docs]</a>def map_async(nr_procs, func, args_iter, daemonic=True, pool=None, **kwargs):
    """Wrap python's ``map_async``

    This has some utility stuff like star passthrough

    Run func on nr_procs with arguments given by args_iter. args_iter
    should be an iterable of the list of arguments that can be unpacked
    for each invocation. kwargs are passed to func as keyword arguments

    Returns:
        (tuple) (pool, multiprocessing.pool.AsyncResult)

    Note: daemonic can be set to False if one needs to spawn child
        processes in func, BUT this could be vulnerable to creating
        an undead army of worker processes, only use this if you
        really really need it, and know what you're doing

    Example:
        &gt;&gt;&gt; func = lambda i, letter: print i, letter
        &gt;&gt;&gt; p, r = map_async(2, func, itertools.izip(itertools.count(), 'abc'))
        &gt;&gt;&gt; r.get(1e8)
        &gt;&gt;&gt; p.join()
        &gt;&gt;&gt; # the following is printed from 2 processes
        0 a
        1 b
        2 c
    """
    args_iter = izip(repeat(func), args_iter, repeat(kwargs))

    # if given a pool, don't close it when we're done delegating tasks
    if pool is not None:
        return pool, pool.map_async(_star_passthrough, args_iter)

    if daemonic:
        pool = mp.Pool(nr_procs)
    else:
        pool = NoDaemonPool(nr_procs)

    with closing(pool) as p:
        return p, p.map_async(_star_passthrough, args_iter)

##
## EOF
##</div>
</pre>

          <footer>
  <hr/>

  <p>
      &copy; Copyright 2013, Kristofor Maynard.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://www.readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>